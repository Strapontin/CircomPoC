# How to go through this project

This repository contains three main examples that I found online to teach under-constrained vulnerabilities in Circom.

I suggest starting with [`Rareskills`](./Rareskills/) since it is the most detailed and the only one that contains an example of altering a witness, although the example is a bit too technical for my taste.

Then, you could check the [`zkSecurity`](./zkSecurity/) example and try to make your own PoC without looking at my solution. If you choose to accept this challenge, read only [`IsZero.circom`](./zkSecurity/IsZero.circom) and the [`makefile`](./zkSecurity/makefile) for convenience.

Finally, the last example is from Oxor. I wasn't able to exploit it and actually believe their code example is a mistake and does not contain a vulnerability. Feel free to play around with the inputs to wrap your head around how it works.

For each folder, a `makefile` contains a shortcut of the command-line instructions to generate the honest proof and the exploit. You can run `make honest` for the honest proof and `make exploit` to generate and test the exploit.

The PoCs in these examples are generated by altering the main Circom circuit to bypass variable calculations that are not enforced by constraints. Every folder contains a file `exploit.circom`, where I have removed the signal that is supposed to be calculated in order to place it as an input parameter, allowing for easier manipulation.

# How to PoC Under-Constrained vulnerabilities on circom

## Part 1. Generating and verifying an honest circuit

### Step 1. Use Circom to create a wasm file

The following command compiles the circuit to an R1CS file and generates a wasm file:

```bash
circom myfile.circom --r1cs --wasm --sym;
```

The files will be created in a new directory, "myfile_js".

### Step 2. Generating the witness

From the R1CS circuit and an `input.json` file, we can generate a file that will be the witness. We will later provide this witness to the verifier.

```bash
cd myfile_js
node generate_witness.js myfile.wasm ../input.json ../witness.wtns
cd ..
```

Using snarkjs, we can view the witness that we generated:

```bash
snarkjs wtns export json witness.wtns witness.json
cat witness.json
```

This JSON file contains the input and output variables sent to the verifier.

### Step 3. Verify the witness

A verifier can check that the witness satisfies the circuit:

```bash
snarkjs wtns check myfile.r1cs witness.wtns
```

## Part 2. Generating an attack

## Update the file to change the constraints

A new file is created, `exploit.circom`. This copy of the main circuit is altered to remove the unconstrained internal signal calculation, which is instead passed as an input. 

Another `input.json` file is also created to provide the new input. We'll call this file `input_exploit.json`.

With both of those files carefully prepared for the exploit, we can run the exploit commands in the `makefile` to generate an R1CS circuit with our variables and verify it. 

When updating the input file for your own tests, you need to ensure the verifier correctly accepts the witness and also ensure that the variable `out` (usually the second parameter in `exploit_witness.json`) is not a possible output in the default circuit! For example, with the Rareskills exercise:

```js
// $cat exploit_witness.json
[
 "1",   // Default value of 1
 "500", // `out`
 "1",   // `a`
 "1",   // `b`
 "5",   // `c`
 "100"  // `i`
]
```
